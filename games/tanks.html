<!DOCTYPE html>
<html>
<head>
    <title>Web Tanks - Dendy Style</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #222;
            color: white;
            text-align: center;
        }
        #gameContainer {
            margin: 0 auto;
            position: relative;
        }
        canvas {
            background: #000;
            display: block;
            margin: 0 auto;
            border: 4px solid #444;
        }
        #menu {
            margin: 20px auto;
            max-width: 800px;
        }
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        #joinCode {
            padding: 8px;
            width: 200px;
        }
        #status {
            margin: 10px 0;
            min-height: 20px;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1>Web Tanks</h1>
        <div id="mainMenu">
            <button id="hostGame">Host Game</button><br>
            <div id="joinSection" class="hidden">
                <input type="text" id="joinCode" placeholder="Enter game code">
                <button id="joinGame">Join Game</button>
            </div>
        </div>
        <div id="gameUI" class="hidden">
            <div id="status">Waiting for players...</div>
            <div id="gameLink"></div>
            <button id="startGame" class="hidden">Start Game</button>
        </div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600" class="hidden"></canvas>
    </div>

    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        // Game constants
        const TANK_SIZE = 30;
        const BULLET_SIZE = 8;
        const TANK_SPEED = 3;
        const BULLET_SPEED = 7;
        const MAX_PLAYERS = 4;
        const TERRAIN_HEIGHT = 150;
        const POWERUP_SIZE = 20;

        // Game state
        let gameState = {
            players: {},
            bullets: [],
            terrain: [],
            powerups: [],
            started: false,
            lastUpdate: 0
        };

        // Local variables
        let peer;
        let myPeerId;
        let isHost = false;
        let myTankId;
        let keys = {};
        let lastShot = 0;
        let canvas, ctx;
        let animationFrame;
        let connections = {};
        let playerColors = ['#FF5252', '#4CAF50', '#2196F3', '#FFC107'];

        // DOM elements
        const hostGameBtn = document.getElementById('hostGame');
        const joinGameBtn = document.getElementById('joinGame');
        const joinSection = document.getElementById('joinSection');
        const joinCodeInput = document.getElementById('joinCode');
        const mainMenu = document.getElementById('mainMenu');
        const gameUI = document.getElementById('gameUI');
        const statusDiv = document.getElementById('status');
        const gameLinkDiv = document.getElementById('gameLink');
        const startGameBtn = document.getElementById('startGame');
        const gameCanvas = document.getElementById('gameCanvas');

        // Initialize
        function init() {
            canvas = gameCanvas;
            ctx = canvas.getContext('2d');
            
            // Show join section after a moment
            setTimeout(() => {
                joinSection.classList.remove('hidden');
            }, 500);

            // Event listeners
            hostGameBtn.addEventListener('click', hostGame);
            joinGameBtn.addEventListener('click', joinGame);
            startGameBtn.addEventListener('click', startGame);
            
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        }

        // Host a new game
        function hostGame() {
            isHost = true;
            myPeerId = 'host-' + Math.random().toString(36).substr(2, 8);
            
            peer = new Peer(myPeerId);
            
            peer.on('open', (id) => {
                statusDiv.textContent = 'Game created! Share this link:';
                const gameLink = `${window.location.href.split('#')[0]}#join=${id}`;
                gameLinkDiv.innerHTML = `<input type="text" value="${gameLink}" readonly style="width:300px;padding:5px;">
                                        <button onclick="copyToClipboard('${gameLink}')">Copy</button>`;
                
                mainMenu.classList.add('hidden');
                gameUI.classList.remove('hidden');
                startGameBtn.classList.remove('hidden');
                
                // Generate terrain
                generateTerrain();
                
                // Add host player
                myTankId = myPeerId;
                gameState.players[myTankId] = createTank(100, canvas.height - TERRAIN_HEIGHT - TANK_SIZE, 0);
                
                // Start listening for connections
                peer.on('connection', (conn) => {
                    conn.on('open', () => {
                        if (Object.keys(gameState.players).length >= MAX_PLAYERS) {
                            conn.send({ type: 'game_full' });
                            conn.close();
                            return;
                        }
                        
                        connections[conn.peer] = conn;
                        
                        // Add new player
                        const tankId = conn.peer;
                        const xPositions = [100, 300, 500, 700];
                        const idx = Object.keys(gameState.players).length;
                        gameState.players[tankId] = createTank(
                            xPositions[idx], 
                            canvas.height - TERRAIN_HEIGHT - TANK_SIZE, 
                            idx
                        );
                        
                        // Send initial game state
                        conn.send({ 
                            type: 'init', 
                            yourTankId: tankId, 
                            gameState: gameState 
                        });
                        
                        // Broadcast to all players about new player
                        broadcast({ type: 'player_joined', tankId });
                        
                        statusDiv.textContent = `Players: ${Object.keys(gameState.players).length}/${MAX_PLAYERS}`;
                        
                        // Handle incoming data
                        conn.on('data', (data) => handleNetworkData(data, tankId));
                        conn.on('close', () => removePlayer(tankId));
                    });
                });
            });
            
            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                statusDiv.textContent = 'Error: ' + err.message;
            });
            
            // Show game canvas
            gameCanvas.classList.remove('hidden');
        }

        // Join an existing game
        function joinGame() {
            const hostId = joinCodeInput.value.trim();
            if (!hostId) return;
            
            myPeerId = 'player-' + Math.random().toString(36).substr(2, 8);
            peer = new Peer(myPeerId);
            
            peer.on('open', (id) => {
                const conn = peer.connect(hostId);
                
                conn.on('open', () => {
                    mainMenu.classList.add('hidden');
                    gameUI.classList.remove('hidden');
                    statusDiv.textContent = 'Connected to game. Waiting for host to start...';
                    
                    // Show game canvas
                    gameCanvas.classList.remove('hidden');
                });
                
                conn.on('data', (data) => {
                    if (data.type === 'init') {
                        myTankId = data.yourTankId;
                        gameState = data.gameState;
                        startGameLoop();
                    } 
                    else if (data.type === 'game_state') {
                        gameState = data.gameState;
                    }
                    else if (data.type === 'game_started') {
                        gameState.started = true;
                        statusDiv.textContent = 'Game started!';
                    }
                    else if (data.type === 'player_joined') {
                        gameState.players[data.tankId] = createTank(
                            100 + Object.keys(gameState.players).length * 200,
                            canvas.height - TERRAIN_HEIGHT - TANK_SIZE,
                            Object.keys(gameState.players).length
                        );
                    }
                    else if (data.type === 'player_left') {
                        delete gameState.players[data.tankId];
                    }
                    else if (data.type === 'game_full') {
                        statusDiv.textContent = 'Game is full!';
                        conn.close();
                    }
                });
                
                conn.on('close', () => {
                    statusDiv.textContent = 'Disconnected from host';
                });
                
                connections[hostId] = conn;
            });
            
            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                statusDiv.textContent = 'Error: ' + err.message;
            });
        }

        // Start the game (host only)
        function startGame() {
            if (!isHost) return;
            
            gameState.started = true;
            broadcast({ type: 'game_started' });
            startGameBtn.classList.add('hidden');
            statusDiv.textContent = 'Game started!';
            
            startGameLoop();
        }

        // Main game loop
        function startGameLoop() {
            if (animationFrame) cancelAnimationFrame(animationFrame);
            
            function gameLoop(timestamp) {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw terrain
                drawTerrain();
                
                // Update and draw players
                if (gameState.started) {
                    updateGame(timestamp);
                }
                
                // Draw players
                Object.values(gameState.players).forEach(player => {
                    drawTank(player);
                });
                
                // Draw bullets
                gameState.bullets.forEach(bullet => {
                    drawBullet(bullet);
                });
                
                // Draw power-ups
                gameState.powerups.forEach(powerup => {
                    drawPowerup(powerup);
                });
                
                // Send inputs if not host
                if (!isHost && gameState.started && myTankId) {
                    sendInput();
                }
                
                animationFrame = requestAnimationFrame(gameLoop);
            }
            
            gameLoop(0);
        }

        // Update game state (host only)
        function updateGame(timestamp) {
            if (!isHost) return;
            
            const deltaTime = timestamp - gameState.lastUpdate;
            gameState.lastUpdate = timestamp;
            
            // Update players based on inputs
            Object.entries(gameState.players).forEach(([id, player]) => {
                if (player.inputs) {
                    if (player.inputs.up) {
                        player.y -= TANK_SPEED;
                        // Check terrain collision
                        if (player.y < canvas.height - TERRAIN_HEIGHT - TANK_SIZE) {
                            player.y = canvas.height - TERRAIN_HEIGHT - TANK_SIZE;
                        }
                    }
                    if (player.inputs.down) {
                        player.y += TANK_SPEED;
                        // Check bottom boundary
                        if (player.y > canvas.height - TANK_SIZE) {
                            player.y = canvas.height - TANK_SIZE;
                        }
                    }
                    if (player.inputs.left) {
                        player.x -= TANK_SPEED;
                        // Check left boundary
                        if (player.x < 0) {
                            player.x = 0;
                        }
                    }
                    if (player.inputs.right) {
                        player.x += TANK_SPEED;
                        // Check right boundary
                        if (player.x > canvas.width - TANK_SIZE) {
                            player.x = canvas.width - TANK_SIZE;
                        }
                    }
                    if (player.inputs.fire && timestamp - player.lastShot > 500) {
                        fireBullet(player);
                        player.lastShot = timestamp;
                    }
                }
            });
            
            // Update bullets
            gameState.bullets.forEach((bullet, index) => {
                bullet.x += bullet.dx * BULLET_SPEED;
                bullet.y += bullet.dy * BULLET_SPEED;
                
                // Check boundaries
                if (bullet.x < 0 || bullet.x > canvas.width || 
                    bullet.y < 0 || bullet.y > canvas.height) {
                    gameState.bullets.splice(index, 1);
                    return;
                }
                
                // Check terrain collision
                if (bullet.y >= canvas.height - TERRAIN_HEIGHT) {
                    // Simple terrain destruction
                    const terrainX = Math.floor(bullet.x);
                    const terrainStart = Math.max(0, terrainX - 10);
                    const terrainEnd = Math.min(canvas.width, terrainX + 10);
                    
                    for (let x = terrainStart; x < terrainEnd; x++) {
                        const dist = Math.sqrt(Math.pow(x - bullet.x, 2));
                        if (dist < 10) {
                            gameState.terrain[x] = Math.min(
                                gameState.terrain[x], 
                                canvas.height - TERRAIN_HEIGHT - 20 + (dist * 2)
                            );
                        }
                    }
                    
                    gameState.bullets.splice(index, 1);
                    return;
                }
                
                // Check player collision
                Object.entries(gameState.players).forEach(([id, player]) => {
                    if (id !== bullet.owner && checkCollision(
                        bullet.x, bullet.y, BULLET_SIZE, BULLET_SIZE,
                        player.x, player.y, TANK_SIZE, TANK_SIZE
                    )) {
                        // Player hit!
                        gameState.bullets.splice(index, 1);
                        
                        // Respawn player
                        setTimeout(() => {
                            gameState.players[id] = createTank(
                                100 + Math.random() * (canvas.width - 200),
                                canvas.height - TERRAIN_HEIGHT - TANK_SIZE,
                                player.colorIndex
                            );
                            broadcast({ type: 'player_respawned', tankId: id, player: gameState.players[id] });
                        }, 1000);
                        
                        return;
                    }
                });
            });
            
            // Check powerup collisions
            gameState.powerups.forEach((powerup, index) => {
                Object.entries(gameState.players).forEach(([id, player]) => {
                    if (checkCollision(
                        powerup.x, powerup.y, POWERUP_SIZE, POWERUP_SIZE,
                        player.x, player.y, TANK_SIZE, TANK_SIZE
                    )) {
                        // Apply powerup
                        // (In a full game, this would give special abilities)
                        gameState.powerups.splice(index, 1);
                        spawnPowerup(); // Replace with new one
                        return;
                    }
                });
            });
            
            // Spawn powerups occasionally
            if (Math.random() < 0.001 && gameState.powerups.length < 3) {
                spawnPowerup();
            }
            
            // Broadcast game state to all players
            broadcast({ type: 'game_state', gameState });
        }

        // Handle network data
        function handleNetworkData(data, tankId) {
            if (data.type === 'input') {
                if (gameState.players[tankId]) {
                    gameState.players[tankId].inputs = data.inputs;
                }
            }
        }

        // Broadcast data to all players
        function broadcast(data) {
            if (!isHost) return;
            
            Object.values(connections).forEach(conn => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }

        // Remove a disconnected player
        function removePlayer(tankId) {
            if (!isHost) return;
            
            delete gameState.players[tankId];
            delete connections[tankId];
            broadcast({ type: 'player_left', tankId });
            statusDiv.textContent = `Players: ${Object.keys(gameState.players).length}/${MAX_PLAYERS}`;
        }

        // Send player input to host
        function sendInput() {
            if (!connections || !myTankId) return;
            
            const hostId = Object.keys(connections)[0];
            if (connections[hostId] && connections[hostId].open) {
                connections[hostId].send({
                    type: 'input',
                    inputs: {
                        up: keys['ArrowUp'] || keys['w'],
                        down: keys['ArrowDown'] || keys['s'],
                        left: keys['ArrowLeft'] || keys['a'],
                        right: keys['ArrowRight'] || keys['d'],
                        fire: keys[' '] || keys['Enter']
                    }
                });
            }
        }

        // Handle keyboard input
        function handleKeyDown(e) {
            keys[e.key] = true;
            
            // Prevent arrow keys from scrolling the page
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'a', 's', 'd'].includes(e.key)) {
                e.preventDefault();
            }
        }

        function handleKeyUp(e) {
            keys[e.key] = false;
        }

        // Create a new tank
        function createTank(x, y, colorIndex) {
            return {
                x: x,
                y: y,
                width: TANK_SIZE,
                height: TANK_SIZE,
                colorIndex: colorIndex,
                lastShot: 0,
                inputs: {}
            };
        }

        // Fire a bullet
        function fireBullet(player) {
            gameState.bullets.push({
                x: player.x + TANK_SIZE / 2 - BULLET_SIZE / 2,
                y: player.y,
                dx: 0,
                dy: -1,
                width: BULLET_SIZE,
                height: BULLET_SIZE,
                owner: myTankId
            });
        }

        // Generate terrain
        function generateTerrain() {
            gameState.terrain = [];
            for (let i = 0; i < canvas.width; i++) {
                // Simple random terrain with some smoothing
                const noise = Math.random() * 20 - 10;
                const prev = gameState.terrain[i-1] || canvas.height - TERRAIN_HEIGHT;
                gameState.terrain[i] = Math.min(
                    canvas.height - 50,
                    Math.max(
                        canvas.height - TERRAIN_HEIGHT - 50,
                        prev + noise
                    )
                );
            }
            
            // Smooth the terrain a bit
            for (let i = 1; i < canvas.width - 1; i++) {
                gameState.terrain[i] = (gameState.terrain[i-1] + gameState.terrain[i] + gameState.terrain[i+1]) / 3;
            }
        }

        // Spawn a powerup
        function spawnPowerup() {
            gameState.powerups.push({
                x: 50 + Math.random() * (canvas.width - 100),
                y: 50 + Math.random() * (canvas.height - TERRAIN_HEIGHT - 100),
                width: POWERUP_SIZE,
                height: POWERUP_SIZE,
                type: Math.floor(Math.random() * 3) // 0-2 for different types
            });
        }

        // Draw terrain
        function drawTerrain() {
            ctx.fillStyle = '#795548';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            
            for (let x = 0; x < canvas.width; x++) {
                ctx.lineTo(x, gameState.terrain[x] || canvas.height - TERRAIN_HEIGHT);
            }
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
        }

        // Draw a tank
        function drawTank(tank) {
            const isMe = tank === gameState.players[myTankId];
            const color = playerColors[tank.colorIndex % playerColors.length];
            
            // Tank body
            ctx.fillStyle = color;
            ctx.fillRect(tank.x, tank.y, tank.width, tank.height);
            
            // Tank barrel
            ctx.fillStyle = '#777';
            ctx.fillRect(
                tank.x + tank.width / 2 - 3, 
                tank.y - 10, 
                6, 
                15
            );
            
            // Highlight if it's the local player
            if (isMe) {
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.strokeRect(tank.x - 2, tank.y - 2, tank.width + 4, tank.height + 4);
            }
        }

        // Draw a bullet
        function drawBullet(bullet) {
            ctx.fillStyle = bullet.owner === myTankId ? '#FFEB3B' : '#FFF';
            ctx.beginPath();
            ctx.arc(
                bullet.x + bullet.width / 2,
                bullet.y + bullet.height / 2,
                bullet.width / 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }

        // Draw a powerup
        function drawPowerup(powerup) {
            const colors = ['#FF5722', '#9C27B0', '#00BCD4'];
            ctx.fillStyle = colors[powerup.type % colors.length];
            ctx.beginPath();
            ctx.arc(
                powerup.x + powerup.width / 2,
                powerup.y + powerup.height / 2,
                powerup.width / 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // Add star shape for visual distinction
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            ctx.moveTo(powerup.x + powerup.width / 2, powerup.y + 2);
            ctx.lineTo(powerup.x + powerup.width - 4, powerup.y + powerup.height - 4);
            ctx.lineTo(powerup.x + 2, powerup.y + powerup.height - 4);
            ctx.closePath();
            ctx.fill();
        }

        // Check collision between two rectangles
        function checkCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 < x2 + w2 &&
                   x1 + w1 > x2 &&
                   y1 < y2 + h2 &&
                   y1 + h1 > y2;
        }

        // Copy to clipboard helper
        function copyToClipboard(text) {
            const input = document.createElement('input');
            input.value = text;
            document.body.appendChild(input);
            input.select();
            document.execCommand('copy');
            document.body.removeChild(input);
            alert('Link copied to clipboard!');
        }

        // Check for join link on page load
        window.addEventListener('load', () => {
            const hash = window.location.hash.substr(1);
            if (hash.startsWith('join=')) {
                joinCodeInput.value = hash.split('=')[1];
            }
            init();
        });
    </script>
</body>
</html>